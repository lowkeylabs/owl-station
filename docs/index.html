<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ROOST</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-45a48b56c8ad2523a9a31c69be39928e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">ROOST</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page">
<span class="menu-text">Home</span></a>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>

  <ul>
  <li><a href="#owl-roost" id="toc-owl-roost" class="nav-link active" data-scroll-target="#owl-roost">OWL-ROOST</a>
  <ul class="collapse">
  <li><a href="#core-concepts" id="toc-core-concepts" class="nav-link" data-scroll-target="#core-concepts">Core Concepts</a>
  <ul class="collapse">
  <li><a href="#decision-options" id="toc-decision-options" class="nav-link" data-scroll-target="#decision-options"><strong>Decision Options</strong></a></li>
  <li><a href="#choice-templates" id="toc-choice-templates" class="nav-link" data-scroll-target="#choice-templates"><strong>Choice Templates</strong></a></li>
  <li><a href="#cases" id="toc-cases" class="nav-link" data-scroll-target="#cases"><strong>Cases</strong></a></li>
  <li><a href="#uncertainty" id="toc-uncertainty" class="nav-link" data-scroll-target="#uncertainty"><strong>Uncertainty</strong></a></li>
  <li><a href="#runs" id="toc-runs" class="nav-link" data-scroll-target="#runs"><strong>Runs</strong></a></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results"><strong>Results</strong></a></li>
  </ul></li>
  <li><a href="#how-the-pieces-fit-together" id="toc-how-the-pieces-fit-together" class="nav-link" data-scroll-target="#how-the-pieces-fit-together">How the Pieces Fit Together</a></li>
  <li><a href="#design-philosophy" id="toc-design-philosophy" class="nav-link" data-scroll-target="#design-philosophy">Design Philosophy</a></li>
  <li><a href="#relation-to-owl-planner" id="toc-relation-to-owl-planner" class="nav-link" data-scroll-target="#relation-to-owl-planner">Relation to OWL-Planner</a>
  <ul class="collapse">
  <li><a href="#owl-planner" id="toc-owl-planner" class="nav-link" data-scroll-target="#owl-planner">OWL-Planner</a></li>
  <li><a href="#how-roost-extends-owl" id="toc-how-roost-extends-owl" class="nav-link" data-scroll-target="#how-roost-extends-owl">How ROOST Extends OWL</a></li>
  <li><a href="#key-extensions-introduced-by-roost" id="toc-key-extensions-introduced-by-roost" class="nav-link" data-scroll-target="#key-extensions-introduced-by-roost">Key Extensions Introduced by ROOST</a></li>
  <li><a href="#when-to-use-owl-vs-roost" id="toc-when-to-use-owl-vs-roost" class="nav-link" data-scroll-target="#when-to-use-owl-vs-roost">When to Use OWL vs ROOST</a></li>
  <li><a href="#in-one-sentence" id="toc-in-one-sentence" class="nav-link" data-scroll-target="#in-one-sentence">In One Sentence</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="owl-roost" class="level1">
<h1>OWL-ROOST</h1>
<p><strong>Retirement Options and Outcomes Studies Tool</strong></p>
<p><strong>ROOST</strong> (Retirement Options and Outcomes Studies Tool) evaluates <strong>retirement decision policies</strong>—not just static plans—by comparing how <strong>agent-controlled actions</strong> perform under <strong>uncertainty</strong> when those decisions are revisited annually.</p>
<p>ROOST is designed to answer questions like:</p>
<blockquote class="blockquote">
<p><em>“Given the uncertainty I face, how flexible are my retirement decisions—and which decision policies are most robust?”</em></p>
</blockquote>
<p>It does this by organizing retirement analysis around a small number of clear, orthogonal concepts.</p>
<section id="core-concepts" class="level2">
<h2 class="anchored" data-anchor-id="core-concepts">Core Concepts</h2>
<p>ROOST introduces five key concepts in extending the work of OWL.</p>
<ul>
<li><strong>Decision options</strong> define <em>what question is being asked</em></li>
<li><strong>Choice templates</strong> define <em>policy alternatives</em></li>
<li><strong>Cases</strong> define <em>assumptions and a snapshot of uncertainty</em></li>
<li><strong>Runs</strong> define <em>a policy instance applied to a case</em></li>
<li><strong>Results</strong> provide <em>evidence for comparison and insight</em></li>
</ul>
<p>Cases and runs are shared between OWL and ROOST. They are represented by exactly the same files and outputs.</p>
<section id="decision-options" class="level3">
<h3 class="anchored" data-anchor-id="decision-options"><strong>Decision Options</strong></h3>
<p>A <strong>decision option</strong> represents a focused retirement question—something the agent can choose and re-choose over time.</p>
<p>Examples:</p>
<ul>
<li>Roth conversion strategy</li>
<li>Spending policy</li>
<li>Social Security claiming strategy</li>
<li>Retirement timing</li>
<li>Asset allocation policy</li>
</ul>
<p>Each decision option defines a <strong>policy dimension</strong> to be explored, not a single action.</p>
</section>
<section id="choice-templates" class="level3">
<h3 class="anchored" data-anchor-id="choice-templates"><strong>Choice Templates</strong></h3>
<p>A <strong>choice template</strong> is a concrete <strong>decision policy</strong> within a decision option. It defines a rule for choosing an action each year, conditional on the current state.</p>
<p>Examples:</p>
<ul>
<li><p><em>Roth options</em>:</p>
<ul>
<li>No Roth conversions</li>
<li>Fixed annual conversion amounts</li>
<li>Fill to a target marginal tax bracket</li>
<li>Let OWL optimize Roth conversions</li>
</ul></li>
<li><p><em>Spending options</em>:</p>
<ul>
<li>Fixed real spending</li>
<li>Guardrail spending</li>
<li>Utility-maximizing spending</li>
<li>“Smile” spending profile</li>
</ul></li>
</ul>
<p>Choice templates are <strong>reusable</strong>, <strong>comparable</strong>, and represent different ways to answer the same underlying decision question.</p>
</section>
<section id="cases" class="level3">
<h3 class="anchored" data-anchor-id="cases"><strong>Cases</strong></h3>
<p>A <strong>case</strong> defines the <strong>initial state and constraints</strong> of a retirement scenario. It is specified by:</p>
<ul>
<li>A TOML plan file</li>
<li>A referenced Household Financial Profile (HFP) file</li>
</ul>
<p>Cases encode <strong>exogenous assumptions</strong> that the agent does not directly control, including:</p>
<ul>
<li>Longevity assumptions</li>
<li>Rates of return and inflation assumptions</li>
<li>Tax rules and policy parameters</li>
<li>Household structure, income sources, and contribution rules</li>
</ul>
<p>These values are treated as <strong>given</strong> for a case and are held fixed when comparing decision policies.</p>
<p>Cases are <strong>sources of truth</strong> and are independent of computed outcomes.</p>
</section>
<section id="uncertainty" class="level3">
<h3 class="anchored" data-anchor-id="uncertainty"><strong>Uncertainty</strong></h3>
<p><strong>Uncertainty</strong> represents aspects of the world that affect outcomes but are <strong>not controlled by the agent</strong>.</p>
<p>In ROOST today, uncertainty is represented <strong>implicitly and scenario-based</strong>:</p>
<ul>
<li>Longevity and return paths are specified <em>ex ante</em> in the case</li>
<li>Each case corresponds to a particular realization or assumption set</li>
<li>Decision policies are evaluated <em>conditional on those assumptions</em></li>
</ul>
<p>ROOST compares <strong>decision policies under a given uncertainty model</strong>, rather than attempting to predict which uncertainty will occur.</p>
<p>This separation allows ROOST to answer questions such as:</p>
<ul>
<li><em>How sensitive is a decision policy to different longevity assumptions?</em></li>
<li><em>Which policies remain robust across pessimistic and optimistic return scenarios?</em></li>
</ul>
<p>Future extensions may introduce richer stochastic or multi-path representations of uncertainty, but the conceptual separation remains the same: <strong>decisions are chosen; uncertainty is not.</strong></p>
</section>
<section id="runs" class="level3">
<h3 class="anchored" data-anchor-id="runs"><strong>Runs</strong></h3>
<p>A <strong>run</strong> is the application of a single <strong>choice template</strong> to a single <strong>case</strong>, producing one realization of outcomes under the case’s uncertainty assumptions.</p>
<p>Conceptually:</p>
<pre><code>Case × Choice Template → Run</code></pre>
</section>
<section id="results" class="level3">
<h3 class="anchored" data-anchor-id="results"><strong>Results</strong></h3>
<p><strong>Results</strong> are the artifacts produced by OWL for a run and form the basis for evaluation and comparison.</p>
<p>Examples:</p>
<ul>
<li>Optimal objective values (max spending, bequest, etc.)</li>
<li>Effective (post-override) TOML and HFP artifacts</li>
<li>Summary and metrics JSON files</li>
<li>Time-series projections and distributions</li>
<li>Comparative tables and visualizations</li>
</ul>
<p>Results are fully reproducible from the effective TOML and HFP alone.</p>
</section>
</section>
<section id="how-the-pieces-fit-together" class="level2">
<h2 class="anchored" data-anchor-id="how-the-pieces-fit-together">How the Pieces Fit Together</h2>
<ul>
<li><strong>Decision options</strong> define <em>what question is being asked</em></li>
<li><strong>Choice templates</strong> define <em>policy alternatives</em></li>
<li><strong>Cases</strong> define <em>assumptions and a snapshot of uncertainty</em></li>
<li><strong>Runs</strong> define <em>a policy instance applied to a case</em></li>
<li><strong>Results</strong> provide <em>evidence for comparison and insight</em></li>
</ul>
<p>In short:</p>
<blockquote class="blockquote">
<p><strong>Decision options define the questions;<br>
choice templates define the policies;<br>
cases define the assumptions and a snapshot of uncertainty;<br>
runs define the policy instance applied to a case;<br>
results define the evidence of a run.</strong></p>
</blockquote>
</section>
<section id="design-philosophy" class="level2">
<h2 class="anchored" data-anchor-id="design-philosophy">Design Philosophy</h2>
<p>ROOST treats retirement planning as a <strong>sequential decision problem</strong>:</p>
<ul>
<li>Decisions are agent-controlled</li>
<li>They are revisited annually</li>
<li>Outcomes unfold under uncertainty</li>
<li>Policies are evaluated for robustness, not just optimality</li>
</ul>
<p>Rather than asking <em>“What is the single optimal plan?”</em>, ROOST helps answer:</p>
<blockquote class="blockquote">
<p><em>“Which decision policies perform well across many plausible futures—and how much flexibility do I really have?”</em></p>
</blockquote>
</section>
<section id="relation-to-owl-planner" class="level2">
<h2 class="anchored" data-anchor-id="relation-to-owl-planner">Relation to OWL-Planner</h2>
<section id="owl-planner" class="level3">
<h3 class="anchored" data-anchor-id="owl-planner">OWL-Planner</h3>
<p><strong>OWL-Planner</strong> (Optimal Wealth Laboratory) is a retirement planning and optimization framework that computes optimal retirement strategies over a full planning horizon, subject to detailed tax rules, account constraints, longevity assumptions, and return scenarios.</p>
<p>Given a fully specified input case—defined by a TOML plan file and a referenced Household Financial Profile (HFP)—OWL solves for optimal actions (such as spending levels, asset allocation, and Roth conversions) under the assumed conditions. OWL’s strength lies in its rigorous optimization engine and its ability to reason consistently across time, taxes, and multiple interacting constraints.</p>
<p>OWL answers questions of the form:</p>
<blockquote class="blockquote">
<p><em>“Given these assumptions and constraints, what strategy is optimal over the planning horizon?”</em></p>
</blockquote>
</section>
<section id="how-roost-extends-owl" class="level3">
<h3 class="anchored" data-anchor-id="how-roost-extends-owl">How ROOST Extends OWL</h3>
<p><strong>ROOST does not replace OWL.</strong> Instead, ROOST <strong>extends OWL by systematizing how retirement decisions are explored, compared, and interpreted under uncertainty.</strong></p>
<p>In particular, ROOST introduces a structured framework for:</p>
<ol type="1">
<li><strong>Explicitly separating agent-controlled decisions from external uncertainty</strong></li>
<li><strong>Organizing retirement analysis around decision policies rather than single optimized plans</strong></li>
<li><strong>Comparing alternative decision policies in a reproducible, scalable way</strong></li>
</ol>
<p>While OWL focuses on computing optimal outcomes for a single, fully specified case, ROOST focuses on exploring <em>decision flexibility and robustness</em> across multiple choices and assumptions.</p>
</section>
<section id="key-extensions-introduced-by-roost" class="level3">
<h3 class="anchored" data-anchor-id="key-extensions-introduced-by-roost">Key Extensions Introduced by ROOST</h3>
<p><strong>1. Decision-centric framing</strong></p>
<p>ROOST treats retirement planning as a sequence of <strong>agent-controlled decisions</strong>—such as spending, Roth conversions, or claiming Social Security—that are revisited annually. These decisions are represented as <strong>decision options</strong>, each supported by multiple <strong>choice templates</strong> (policy rules).</p>
<p>This framing makes explicit that:</p>
<ul>
<li>Decisions are chosen by the agent</li>
<li>They can be discrete or continuous</li>
<li>They are evaluated as <em>policies</em>, not one-time actions</li>
</ul>
<p><strong>2. Explicit treatment of uncertainty</strong></p>
<p>In ROOST, uncertainty is treated as <strong>exogenous</strong>:</p>
<ul>
<li>Longevity assumptions</li>
<li>Return and inflation paths</li>
<li>Tax and policy environments</li>
</ul>
<p>These elements are encoded in <strong>cases</strong> and are not directly controlled by the agent. Decision policies are evaluated <em>conditional on this uncertainty snapshot</em>, allowing ROOST to explore sensitivity and robustness without conflating choices with outcomes.</p>
<p><strong>3. Systematic comparison of alternatives</strong></p>
<p>ROOST introduces structure around OWL runs by:</p>
<ul>
<li>Applying multiple choice templates to one or more cases</li>
<li>Executing these runs in a consistent, reproducible manner</li>
<li>Capturing comparable results and artifacts for analysis</li>
</ul>
<p>This enables ROOST to answer questions such as:</p>
<ul>
<li><em>Which decision policies perform best under a given set of assumptions?</em></li>
<li><em>How sensitive are outcomes to different first-year decisions?</em></li>
<li><em>Where does meaningful flexibility exist across plausible futures?</em></li>
</ul>
<p>Below is a <strong>respectful, balanced “When to Use OWL vs ROOST” section</strong> you can append immediately after <strong>“How ROOST Extends OWL”</strong> in the new <em>Relation to OWL-Planner</em> section. It is careful to position ROOST as <em>complementary</em>, not superior, and to emphasize OWL’s strengths clearly.</p>
</section>
<section id="when-to-use-owl-vs-roost" class="level3">
<h3 class="anchored" data-anchor-id="when-to-use-owl-vs-roost">When to Use OWL vs ROOST</h3>
<p><strong>OWL and ROOST are complementary tools</strong>, designed to answer different—but closely related—questions in retirement planning.</p>
<section id="use-owl-planner-when-you-want-to" class="level4">
<h4 class="anchored" data-anchor-id="use-owl-planner-when-you-want-to">Use <strong>OWL-Planner</strong> when you want to:</h4>
<ul>
<li>Solve a <strong>single, well-defined retirement case</strong></li>
<li>Compute an <strong>optimal strategy</strong> under a specific set of assumptions</li>
<li>Explore the implications of detailed tax, account, and timing constraints</li>
<li>Generate a <strong>best-response plan</strong> given fixed inputs</li>
</ul>
<p>OWL is ideal when the question is:</p>
<blockquote class="blockquote">
<p><em>“Given these assumptions, what strategy is optimal over the planning horizon?”</em></p>
</blockquote>
<p>OWL’s optimization engine is the authoritative source for computing internally consistent, horizon-wide solutions.</p>
</section>
<section id="use-roost-when-you-want-to" class="level4">
<h4 class="anchored" data-anchor-id="use-roost-when-you-want-to">Use <strong>ROOST</strong> when you want to:</h4>
<ul>
<li><strong>Compare multiple decision policies</strong>, not just a single optimized plan</li>
<li>Explore <strong>trade-offs and robustness</strong> across alternative choices</li>
<li>Understand <strong>decision flexibility</strong> under uncertainty</li>
<li>Systematically evaluate <em>families of strategies</em> (e.g., Roth policies, spending rules, claiming strategies)</li>
<li>Organize and automate <strong>reproducible experiments</strong> across cases and choices</li>
</ul>
<p>ROOST is ideal when the question is:</p>
<blockquote class="blockquote">
<p><em>“Across plausible decision policies and assumptions, which choices perform well—and how sensitive are outcomes to what I decide today?”</em></p>
</blockquote>
<p>ROOST builds on OWL by running it repeatedly in a structured way, making comparisons explicit and interpretable.</p>
</section>
<section id="how-they-work-together" class="level4">
<h4 class="anchored" data-anchor-id="how-they-work-together">How They Work Together</h4>
<p>A typical workflow looks like:</p>
<ol type="1">
<li><strong>Define a case</strong> (TOML + HFP)</li>
<li><strong>Use ROOST</strong> to explore and compare decision policies</li>
<li><strong>Use OWL outputs</strong> to understand the mechanics and outcomes of each policy</li>
<li><strong>Focus decision-making</strong> on policies that appear robust and flexible</li>
<li>Optionally, <strong>refine or deepen analysis in OWL</strong> for a specific scenario</li>
</ol>
<p>In this sense:</p>
<ul>
<li><strong>OWL provides the optimization engine</strong></li>
<li><strong>ROOST provides the experimental framework</strong></li>
</ul>
<p>ROOST does not replace OWL’s role; it amplifies its usefulness by placing individual OWL runs in a broader decision-analysis context.</p>
</section>
</section>
<section id="in-one-sentence" class="level3">
<h3 class="anchored" data-anchor-id="in-one-sentence">In One Sentence</h3>
<blockquote class="blockquote">
<p><strong>Use OWL to find optimal strategies for a given case; use ROOST to compare and understand decision policies across uncertainty.</strong></p>
</blockquote>
<p>This distinction keeps each tool focused on what it does best, while allowing them to work together naturally.</p>
</section>
<section id="summary" class="level3">
<h3 class="anchored" data-anchor-id="summary">Summary</h3>
<p>In short:</p>
<ul>
<li><strong>OWL</strong> computes optimal strategies for a given case</li>
<li><strong>ROOST</strong> compares decision policies across cases to understand trade-offs, uncertainty, and flexibility</li>
</ul>
<p>ROOST builds on OWL’s optimization engine by providing the conceptual structure and tooling needed to explore retirement decisions as they are actually faced: sequentially, under uncertainty, and with multiple plausible policies under consideration.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button,
          { trigger: "manual",
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config);
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined;
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              }
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            }
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>
